<html>
<head>
<title>学習用第２章</title>
</head>
<body>
<script  type="text/javascript">


document.write('<br>');
document.write('デフォルト値を模したイディオム');
document.write('引数1-2-3<br>');
var value = {x:1, y:2, z:3 };
var value1 = getDistance(value);
document.write('x:' + value1.x + 'y:' + value1.y + 'z:' + value1.z +  '<br>');

function getDistance(pos){
	pos = pos || { x:0, y:0, z:0 }; //引数posがなければデフォルト値を使う
	return Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
}

document.write('<br>');
document.write('コンストラクタとクラス定義');
document.write('JavaやC++のようにクラスを定義する構文にある言語の経験者には前節で説明したJavaScriptのコンストラクタが奇妙に見えるかもしれません<br>');
document.write('普通の関数をnew式で呼び出してオブジェクトを生成するのは言語仕様としてわかりやすいとはいえないからです。<br>');
document.write('しかし、クラス定義に必要な機能は満たしています。<br>');

//クラス定義相当
function MyClass(x, y)
{
	//フィールド相当
	this.x = x;
	this.y = y;
	//メソッド相当
	this.show = function() {
		document.write('x:' + this.x +' y:' + this.y);
	}
}
//コンストラクタの呼び出し
var obj = new MyClass(3,2);
obj.show();

document.write('function MyClass(x, y)<br>');
document.write('{<br>');
document.write('	this.x = x;<br>');
document.write('	this.y = y;<br>');
document.write('	this.show = function() {<br>');
document.write('		document.write(\'x:\' + this.x +\' y:\' + this.y);<br>');
document.write('	}<br>');
document.write('}<br>');
document.write('var obj = new MyClass(3,2);<br>');
document.write('obj.show();<br>');

document.write('<br>');
document.write('プロパティ名の列挙にはfor in文を使います。<br>');
document.write('プロパティ値の列挙はfor in文の中でブラケット演算子を使うことで間接的に可能です。<br>');
document.write('for each in文を使うと直接プロパティ値を列挙できます。<br>');

var obj = { x:3, y:4, z:5 };
for (var key in obj) {
	document.write('key = ' + key + '<br>');
	document.write('val = ' + obj[key] + '<br>');
}
document.write('<br>');
document.write('var obj = { x:3, y:4, z:5 };<br>');
document.write('for (var key in obj) {<br>');
document.write('	document.write(\'key = \' + key);<br>');
document.write('	document.write(\'val = \' + obj[key]);<br>');
document.write('}<br>');

document.write('連想配列の操作<br>');
document.write('<br>');
document.write('連想配列は要素の集合体です。要素はキーと値のペアです。連想配列の操作は、キーで値の取得、要素のセット、要素の削除の３つです。<br>');
document.write('実態はJavaScriptのオブジェクトなので要素とはプロパティの言い換えに過ぎません。<br>');
document.write(' キーと値はプロパティ名とプロパティ値の言い換えです。<br>');
document.write('キーから値を取得する方法はプロパティアクセスの節で説明したようにドット演算子もしくはプラケット演算子を使います。厳密には右辺値として使うのが正しい説明です。<br>');
document.write('要素のセットは、ドット演算子もしくはプラケット演算子を左辺値にして代入式を書きます。<br>');
document.write('要素の削除にはdelete演算子を使います。オブジェクトの用語を使うとプロパティの削除です。<br>');

document.write('<br>');

var map = {x:3, y:4};
document.write(map.x + '<br>');
delete map.x;
document.write(map.x + '<br>');
document.write('<br>');
document.write('var map = {x:3, y:4};<br>');
document.write('document.write(map.x);<br>');
document.write('delete map.x;<br>');
document.write('document.write(map.x);<br>');

document.write('<br>');
document.write('連想配列としてオブジェクトの注意点<br>');
document.write('　連想配列としてのオブジェクトにはプロトタイプ継承に絡む注意点があります。<br>');
document.write('プロトタイプ継承を極端に言うと他のオブジェクトのプロパティを継承して、あたかもオブジェクト自身のプロパティのように扱える仕組みです。<br>');
document.write('　形式的には次のようになります。オブジェクトのプロパティzは直接のプロパティではなくプロントタイプ継承したプロパティです。<br>');
document.write('<br>');

function MyClass1() {}
MyClass1.prototype.z = 5;
var obj = new MyClass1();
document.write('継承したプロパティ：' + obj.z + '<br>');


document.write('function MyClass1() {}<br>');
document.write('MyClass1.prototype.z = 5; //プロトタイプチェーン上にプロパティｚをセット<br>');
document.write('var obj = new MyClass1();<br>');
document.write('document.write(\'継承したプロパティ：\' + obj.z); //プロパティｚをプロトタイプ継承している<br>');
document.write('<br>');
document.write('for in 文はプロトタイプ継承したプロパティも列挙します。<br>');
document.write('for (var key in obj) {<br>');
document.write('	document.write(\'for文:\' + key);<br>');
document.write('}<br>');

for (var key in obj) {
	document.write('for文:' + key + '<br>');
}

document.write('<br>');
document.write('　プロトタイプ継承したプロパティはdelete出来ないことに注意してください。前コードの続きはこのようになる<br>');
document.write('<br>');
delete obj.z;
document.write('delete obj.z;<br>');
document.write('deleteを書けた後の値:' + obj.z + '<br>');

document.write('<br>');
document.write('　オブジェクトを連想配列として扱う場合、オブジェクトリテラルで生成するのが一般的です。<br>要素の無い連想配列を作るつもりで空のオブジェクトリテラルを使っても、実際にはObjectクラスからプロパティをプロトタイプ継承しているので注意してください。<brこの存在チェックはin演算で可能です。><br>');
document.write('<br>');
document.write('var map = {};<br>');
document.write('document.write(\'結果：\');<br>');
document.write('document.write(\'toString\' in map);<br>');

var map = {};
document.write('結果：');
document.write('toString' in map);
document.write('<br>');

document.write('<br>');
document.write(' しかし、for in文で要素を列挙すると何も列挙されません。<br>これはenumerable属性のためです<br>');

document.write('for (var key in map) {<br>');
document.write('	document.write(\'for文:\' + map);<br>');
document.write('}<br>');

for (var key in map) {
	document.write('for文:' + map + '<br>');
}

document.write('<br>');
document.write(' プロパティの属性<br>');
document.write(' 用語が紛らわしいですがプロパティのには属性（attribute)があります<br>');
document.write('ECMAScriptでは、プロパティ値を「値属性」という属性の１つと位置づけています。<br>');
document.write('この定義を使うとプロパティとは名前（プロパティ名）と複数の属性の集まりになります。<br>');
document.write('本書は直感的な馴染みやすさを優先して値と属性を別に扱います。<br>');


document.write('変数とオブジェクト<br>');
document.write('　最初にオブジェクトの参照を変数objに代入しています。このオブジェクトは２つのプロパティを持ちます。<br>');
document.write('プロパティｘの値は数値３で、プロパティdoitの値は関数です。この関数をメソッドdoitと呼ぶことにします。<br>');
document.write('　objに対するドット演算子あるいはブラケット演算子でメソッドdoitを呼び出せます。<br>この時、メソッド呼び出し対象のオブジェクトをレシーバオブジェクトと呼びます（つまり変数objが参照するオブジェクトがレシーバオブジェクトです）。 <br>');
document.write('　呼びだされたメソッド内のthis参照はレシーバオブジェクトを参照します。<br>');
document.write('　このthis参照の挙動によりjavaやC++のメソッドに似た動作になります。<br>ただ微妙に異なる挙動もすることがあります。<br>');
document.write('こちらは、レシーバオブジェクトを明確的に指定するために使えます<br>');

var obj = {
	x:3 ,
	doit: function() { document.write('method is called. ' + this.x); }
};

obj.doit();
document.write('<br>');
obj['doit']();


document.write('<br>');
document.write('プロトタイプ継承<br>');
document.write('<br>');
document.write('　プロトタイプ継承の内部は複雑です。<br>');
document.write('単にプロトタイプ継承を使いたいだけの人には却って混乱を招く危険があります。<br>');

function MyClass2(x,y) {
	this.x = x;
	this.y = y;
}
MyClass2.prototype.show = function() {
	//document.write('x:' + this.x + 'y:' + this.y + '<br>');
}

document.write('<br>');
document.write('方判定ダックタイピング<br>');
document.write('　クラスと（インスタンス）オブジェクトという静的な関係であればinstanceof演算子によるオブジェクトの型判定で話は終わります<br>');
document.write('オブジェクト生成後に新たなプロパティを追加することや、コンストラクタと無関係にオブジェクトを構築していくのは日常茶番です。<br>');

var obj = {}; //空のオブジェクト生成
obj.doit = function() { document.write('doit<br>'); } //プロパティの追加

//コンストラクタなしでオブジェクト生成
var obj = { doit: function() { document.write('doit<br>'); } }
document.write('<br>');
document.write('　上記のオブジェクトはdoitというメソッドを持ちます。どんなメソッドを持つかはオブジェクトの振る舞いの重要な指標ですが、doitメソッドの存在はconstructorプロパティやinstanceof演算では判定できません。<br>');
document.write('　instanceof演算より更に凡庸的な方判定の手段は、そのオブジェクトにどんなプロパティがあるのかを判定する方法です。<br>');
document.write('オブジェクトの振る舞いを直接調べて型を判定する手法を俗にダックタイピングと呼びます。<br>');
document.write('　ダックタイピングに使える１つの方法がin演算です。左辺にプロパティ名の文字列、右辺にオブジェクト参照を指定します。オブジェクトが指定プロパティをもつ場合、演算結果が真になります。プロトタイプチェーンで継承したプロパティも判定できます。<br>');


document.write('var obj = { doit: function() { document.write(\'doit\'); }} //プロパティの追加 <br>');
var obj = { doit: function() { document.write('doit<br>'); }} //プロパティの追加
document.write('doit:');
document.write('doit' in obj);
document.write('<br>');
document.write('toString:');
document.write('toString' in obj);
document.write('<br>');

document.write('<br>');
document.write('<br>');


document.write('直接のプロパティのみを列挙するコード<br>');
document.write('for (var key in obj) {<br>');
document.write('	if(obj.hasOwnProperty(key)) {<br>');
document.write('		document.write(key);<br>');
document.write('	}<br>');
document.write('}<br>');

document.write('出力結果：');
for (var key in obj) {
	if(obj.hasOwnProperty(key)) {
		document.write(key);
	}
}
document.write('<br>');

document.write('第5のobjctクラス<br>');
document.write('　objectクラスのcreateメソッドは、オブジェクトリテラル、new式に続くオブジェクト生成の台３の合志区手段です。<br>');
document.write('第一にプロトタイプオブジェクトにnullを渡すとobjectすらプロトタイプ継承しないオブジェクトを生成できます。<br>');

document.write('<br>');

document.write('//objectをプロトタイプ継承しないオブジェクト<br>');
document.write('var obj = Object.create(null);<br>');
document.write('document.write(Object.getPrototypeOf(obj));<br>');
document.write('document.write(\'toString\' in obj);<br>');

document.write('<br>');
//objectをプロトタイプ継承しないオブジェクト
var obj = Object.create(null);
document.write('Object.getPrototypeOf(obj): ');
document.write(Object.getPrototypeOf(obj));
document.write('<br>\'toString\' in obj: ');
document.write('toString' in obj);
document.write('<br>');
document.write('オブジェクトリテラルで生成した場合と同じ効果は次のコードで得られます<br>');
var obj = Object.create(Object.prototype); // var obj = {}と等価
document.write('var obj = Object.create(Object.prototype); // var obj = {}と等価<br>');


document.write('<br>');
document.write('Object.createメソッドを使うとプロトタイプ継承したコードをより直感的に記述できます。<br>');
document.write('<br>');
function MyClass3() {}
var Proto = {x:2, y:3};
MyClass.prototype = Proto;
var obj = new MyClass3();
//これと等価なコードが以下
var Proto = {x:2, y:3};
var obj = Object.create(Proto);


document.write('function MyClass3() {}<br>');
document.write('var Proto = {x:2, y:3};<br>');
document.write('MyClass.prototype = Proto;<br>');
document.write('var obj = new MyClass3();<br>');
document.write('//これと等価なコードが以下<br>');
document.write('var Proto = {x:2, y:3};<br>');
document.write('var obj = Object.create(Proto);<br>');
document.write('<br>');
document.write('継承していることを確認:' + obj.x + '-' + obj.y + '<br>');



document.write('　get属性とset属性に関数を指定するとゲッターとセッターのアクセッサでのみ値にアクセス可能なプロパティを定義できます。<br>');
document.write('アクセッサとvalue属性は排他の関係です。つまりvalue属性を指定するとアクセッサ(getとsetの両方)は無効になり、アクセッサ（getとsetいずれか)を指定するとvalue属性が無効になります。<br>');
document.write('　get属性には値を返す関数、set属性には引数を１つ受け取り内部で状態を変更する関数を指定します。<br>');
document.write('内部的にはプロパティを右辺値としてアクセスした時にゲッター関数が呼ばれて、左辺値として値を代入した時にセッター関数が呼ばれます<br>');
document.write('言語仕様的にはget属性が副採用のある関数でも違反ではありませんが、意味は無いのでアクセッサらしい関数にしてください。<br>');
document.write('正しくアクセッサ関数を書けばゲッターのみのプロパティで不変pブジェクと作製の助けになります。<br>');

var obj = Object.create(Object.prototype,
		{ x:{ get:function(){ document.write('get called<br>');},
			set:function(v) { document.write('set called');}
			}
			});

document.write('<br>');
document.write(obj.x);
document.write('<br>');
obj.x = 1;
document.write('<br>');
document.write(obj.x);


document.write('<br>');




document.write('<br>');
document.write('<br>');








document.write('<br>');
document.write('<br>');
document.write('<br>');
document.write('<br>');
document.write('<br>');
document.write('<br>');
document.write('<br>');








</script>
</body>
</html>
